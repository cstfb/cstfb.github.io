<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[西央]]></title>
  <link href="fengbo.cool/atom.xml" rel="self"/>
  <link href="fengbo.cool/"/>
  <updated>2022-03-13T21:04:57+08:00</updated>
  <id>fengbo.cool/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[OGNL]]></title>
    <link href="fengbo.cool/ongl.html"/>
    <updated>2019-06-16T22:22:28+08:00</updated>
    <id>fengbo.cool/ongl.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring + Mybatis 读写分离]]></title>
    <link href="fengbo.cool/rw-splitting.html"/>
    <updated>2019-06-08T22:26:56+08:00</updated>
    <id>fengbo.cool/rw-splitting.html</id>
    <content type="html"><![CDATA[
<p>现在的应用在存储上很多都是一主一从或者一主多从，为了充分发挥从库的优势，在应用层面做到读写分离是一个很好的切入点，在Spring+mybatis的技术栈下，有几个方法:</p>

<h2 id="toc_0">方法一：SQL做数据源隔离</h2>

<p>将查询主库的SQL和查询从库的SQL放在不同的目录下，然后配置不同的数据源。</p>

<pre><code class="language-text">&lt;!--w--&gt;
&lt;bean id=&quot;masterSqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;masterDataSource&quot;/&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:updateDao/mapper/*.xml&quot;/&gt;
&lt;/bean&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.xxx.updateDao&quot; /&gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;masterSqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;!--r--&gt;
&lt;bean id=&quot;slaveSqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;slaveDataSource&quot;/&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:queryDao/mapper/*.xml&quot;/&gt;
&lt;/bean&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.xxx.queryDao&quot; /&gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;slaveSqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;!--  --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;masterDataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>这么做比较简单，但会造成读和写的代码分开；</p>

<p>接下来的方法都会用到AbstractRoutingDataSource这个抽象类。</p>

<h2 id="toc_1">方法二: Mybatis拦截器+AbstractRoutingDataSource</h2>

<p>通过mybatis插件拦截sql执行，通过对每条sql的xml配置解析来判断走主库还是从库。将主库或者从库的对应枚举设置到全局的ThreadLocal中，结合Abstra ctRoutingDataSource通过读取当前线程的数据源类型来控制执行sql时采用哪一个DataSource，sql完成之后清除ThreadLocal。<br/>
<img src="media/15600040161314/%E2%80%9CWechatIMG28%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC.jpg" alt="“WechatIMG28”的副本"/></p>

<h2 id="toc_2">方法三: 注解AOP+AbstractRoutingDataSource</h2>

<p>不使用Mybatis插件也可以使用AOP拦截。<br/>
<img src="media/15600040161314/%E2%80%9CWechatIMG29%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC.jpg" alt="“WechatIMG29”的副本"/></p>

<h2 id="toc_3">注意事项</h2>

<p>1.在高负载下，数据库更新会存在主从延迟。如果业务代码要求读实时数据的场景，必须强制注解从主库查询。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM压缩指针(CompressedOops)]]></title>
    <link href="fengbo.cool/CompressedOops.html"/>
    <updated>2019-06-08T21:08:36+08:00</updated>
    <id>fengbo.cool/CompressedOops.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">问题背景</h2>

<p>之前看到一篇文章说到<a href="https://www.elastic.co/cn/blog/a-heap-of-trouble?nsukey=ycffxylI5WOlirpUecMZ0%2Bh6dId%2F6txxdsCpmHZgpChzNei9bZBIb5k0f9y5MKNNnkdZW7301ucVHpE0ODBPYdqnmTUToaWRoRTXDaylGHoP%2BFuwyBHyl6E18mobs1pLswxMBan5gDjYNs74O9RcV7kMcjgr3HZ2jyStMP9hbxU9i88t%2FFDGLn36j3jcOq5lh81YNxpf37kwDWQX5v4qNQ%3D%3D">es的内存调优</a>, 文章说到现在的服务器越来越大， 那么给JVM设置多大的内存比较合适呢？太大的话虽然内存充足，但是会带来gc停顿时间的增大，对于es这一类需要快速响应的应用来说是不可接受的，太小则会有OOM的风险。因此内存需要设置的刚刚好。</p>

<h2 id="toc_1">What is CompressedOops</h2>

<p>压缩指针则提供了一种既可以享受到大内存的好处，同时可以节约内存空间并且提高性能的方法。在某些情况下，它可以达到性能与停顿时间的平衡。</p>

<blockquote>
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#zeroBasedCompressedOop">ref</a> On an LP64 system, the heap used by a given program might have to be around 1.5 times larger than when it is run on an ILP32 system.</p>
</blockquote>

<p>在64位系统中，对象指针也是64位，因此可以使用更大的内存，而在32位系统中是32位，最多只能使用4G的内存。对象指针长度的增大也会带来内存开销，而这种开销的差距在64位和32位系统之间可能是1.5倍，也就是说在如果32位系统使用4G内存达到的效果可能64位系统使用6G内存才能达到。<br/>
在很多情况下，这种开销是不必要的，并且会提高系统停顿时间，因为很多时候应用只需要32位指针就够了。<br/>
压缩指针提供了一种折中的选择，在JDK7中(64位)，如果堆小于4G，JVM会默认使用32位对象指针。<br/>
那显然这种优化只能覆盖一部分的情况，为了享受大内存，很多应用会开比4G大得多的堆，这时候是不是就必须用64位指针了呢？ 答案是不是，在堆小于32G(不精确)的情况下，此时对象地址只需要使用35位地址(32位=4G, 4G * 2<sup>3</sup> = 32G)即可, 此时如果操作系统允许，JVM会将对象指针右移3位进行存储，也就是说还是只需要32位地址就行了，此时会有两个问题:</p>

<ul>
<li>那么这时候会出现的问题就是右边3位丢失了怎么办？ </li>
<li>存储的地址和实际的地址相差八倍，即每两个指针之间有8个字节的空档，这其中存在内存的‘空隙’如何处理?</li>
</ul>

<p>第一个问题最简单的情况下就是右边3位全是0，那么在转换过程中只需要右移三位和左移三位即可(也即是zero-based compressed oops)，非常方便；如果右边三位不为0，那么这时候就需要加入一个偏移量的计算，对性能会有一定的损耗。<br/>
第二个问题是关于为什么是三位而不是四位五位的问题， 压缩后的指针有可能是0x0, 0x1, 0x2， 解压后的指针则是0x0, 0x8, 0x10, 中间有8个字节的空档，这个问题的答案和对象对齐有关，在JVM中对象是默认8字节对齐的，所以基本上着正好符合JVM本身的设计，(要注意的是对象对齐本身也会提高内存开销)。<br/>
<img src="media/15599993168030/%E2%80%9CWechatIMG27%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC.jpg" alt="“WechatIMG27”的副本"/></p>

<h2 id="toc_2">最佳实践</h2>

<p>在满足内存和吞吐量的情况下，JVM堆内存设置的越小越好； 如果不能，那么考虑分配的内存满足压缩指针的要求，从而达到优化的效果。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[负载均衡算法]]></title>
    <link href="fengbo.cool/load-balancer-algorithm.html"/>
    <updated>2019-05-12T18:06:59+08:00</updated>
    <id>fengbo.cool/load-balancer-algorithm.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Round-Robin(轮询)</h2>

<pre><code class="language-text">public class RoundRobin {
    private Object[] hosts; // hosts列表
    private int len; // hosts数量
    private AtomicInteger increr = new AtomicInteger(0); // 自增器
    // constructor
    public RoundRobin(Object... hosts) {
        Preconditions.checkNotNull(hosts);
        this.hosts = hosts;
        len = hosts.length;
    }
    // get next hosts
    public Object get() {
        int cur = increr.incrementAndGet();
        if (cur &gt; 0x70000000) {
            increr.set(0);
        }
        return hosts[cur % len];
    }
    // get request cnt
    public int getCnt() {
        return increr.get();
    }

    public static void main(String[] args) throws Exception {
        int i = 0;
        RoundRobin rr = new RoundRobin(&quot;10.1.1.1&quot;, &quot;10.1.1.2&quot;, &quot;10.1.1.3&quot;);
        AtomicLong totalTime = new AtomicLong(0L);

        // 模拟多线程环境测试QPS
        int maxThread = 1;
        // 10线程
        ExecutorService es = Executors.newFixedThreadPool(maxThread);
        while (maxThread &gt; 0) {
            es.execute(() -&gt; {
                long t1 = System.currentTimeMillis();
                try {
                    while (!Thread.interrupted()) {
                        rr.get();
                    }
                    long t2 = System.currentTimeMillis();
                    totalTime.addAndGet(t2 - t1);
                } catch (Exception e2) {
                    e2.printStackTrace();
                }
            });

            maxThread --;
        }

        // 
        Thread.sleep(1000);
        
        es.shutdownNow();
        es.awaitTermination(1, TimeUnit.MINUTES);

        System.out.println(&quot;total cpu time:&quot; + totalTime.get());
        System.out.println(&quot;total request count:&quot; + rr.getCnt());
    }
}
</code></pre>

<p>使用juc提供的Atomic类来做自增操作。</p>

<h2 id="toc_1">Weighted Round-Robin(加权轮询)</h2>

<p>当需要为不同的节点分配不同的权重时，例如当各个节点的吞吐量不同，这时候可以使用加权轮询， 例如有A,B,C三个服务器，然后权重分别是4，3，2，那么一个典型的请求序列可以是AABCACABC;</p>

<pre><code class="language-text">public class WeightedRoundRobin {
    private List&lt;Server&gt; servers;
    private int totalWeight;
    // init
    public WeightedRoundRobin() {
        this.servers = new ArrayList();
        this.totalWeight = 0;
    }
    // 添加hosts
    public void addServer(String ip, int weight) {
        this.servers.add(new Server(ip, weight));
        this.totalWeight += weight;
    }
    // get
    public Server getServer() {
        Server best = null;

        for (Server srv : servers) {
            srv.effectiveWeight += srv.weight;

            if (null == best || best.effectiveWeight &lt; srv.effectiveWeight) {
                best = srv;
            }
        }
        if (best != null) {
            best.effectiveWeight -= totalWeight;
        }
        return best;
    }

    public static void main(String[] args) {
        WeightedRoundRobin wrr = new WeightedRoundRobin();
        wrr.addServer(&quot;10.1.1.1&quot;, 3);
        wrr.addServer(&quot;10.1.1.2.&quot;, 2);
        wrr.addServer(&quot;10.1.1.3&quot;, 1);

        int cnt = 50;
        while(cnt &gt; 0) {
            System.out.println(wrr.getServer());
            cnt -= 1;
        }
    }
}

class Server{
    String ip;
    int weight;
    int effectiveWeight;

    public Server(String ip, int weight) {
        this.ip = ip;
        this.weight = weight;
        this.effectiveWeight = 0;
    }

    @Override
    public String toString() {
        return &quot;ip:&quot; + ip + &quot;, weight:&quot; + weight;
    }
}
</code></pre>

<p>上面的代码是<code>平滑加权平均算法</code>的一个实现, 这个算法实现比较巧妙， 对于一个<code>Server</code>对象，除了<code>weight权重</code>外， 还有一个<code>effectiveWeight有效权重</code>字段， 表示<code>server</code>当前的权重，每次轮询，<code>effectiveWeight</code>加一次的<code>weight</code>, 然后选取<code>effectiveWeight</code>最大的那个<code>server</code>, 然后<code>effectiveWeight</code>减去<code>totalWeight</code>, 循环这个过程, 算法描述如下:</p>

<ol>
<li>初始化每个<code>server</code>的权重<code>wi</code>, 设置当前有效权重<code>cwi</code>为<code>wi</code>, 并求得<code>totalWeight</code></li>
<li>选取<code>cwi</code>最大的<code>server</code>, 并且将<code>cwi</code>减去<code>totalWeight</code>, <code>best</code>指向当前<code>server</code></li>
<li>将每个<code>server</code>的<code>cwi</code>加上<code>wi</code></li>
<li>返回<code>best</code></li>
<li>每次调度重复2,3,4步</li>
</ol>

<h2 id="toc_2">Least-Connection Scheduling(最小连接)</h2>

<p>最小连接调度把当前连接数最小的服务器分配给新的连接。</p>

<pre><code class="language-text">public class LeastConnection {
    private List&lt;LeastConnectionServer&gt; servers;
    public LeastConnection(String... ips) {
        servers = new ArrayList&lt;&gt;();
        for(String ip : ips) {
            servers.add(new LeastConnectionServer(ip));
        }
    }
    public LeastConnectionServer getServer() {
        LeastConnectionServer best = null;
        for (LeastConnectionServer srv : servers) {
            if(null ==  best || best.connCnt.get() &gt; srv.connCnt.get()) {
                best = srv;
            }
        }
        best.connCnt.incrementAndGet();
        return best;
    }
    public void returnServer(LeastConnectionServer srv) {
        if (null != srv) {
            srv.connCnt.getAndAdd(-1);
        }
    }
    public static void main(String[] args) {
        LeastConnection wrr = new LeastConnection(&quot;10.1.1.1&quot;, &quot;10.1.1.2&quot;, &quot;10.1.1.3&quot;);

        int cnt = 50;
        while(cnt &gt; 0) {
            System.out.println(wrr.getServer());
            cnt -= 1;
        }
    }
}

class LeastConnectionServer{
    String ip;
    AtomicInteger connCnt;

    public LeastConnectionServer(String ip) {
        this.ip = ip;
        this.connCnt = new AtomicInteger(0);
    }

    @Override
    public String toString() {
        return &quot;ip:&quot; + ip + &quot;, connection_cnt:&quot; + connCnt.get();
    }
}
</code></pre>

<h2 id="toc_3">Weighted Least-Connection Scheduling(加权最小连接)</h2>

<p>加权最小连接工作方式如下:<br/>
假如有n个服务器, 服务器i权重为\(W_i (i=1,..,n)\), 存活连接数为\(C_i (i=1,..,n)\), \(ALL\_CONNECTIONS = sum(C_i (i=1,..,n)\), 下面的连接会指向服务器\(j\)满足条件：<br/>
\((C_j/ALL\_CONNECTIONS)/W_j = min { (C_i/ALL\_CONNECTIONS)/W_i } (i=1,..,n)\)<br/>
\(ALL\_CONNECTIONS\)可以约掉:<br/>
\(C_j/W_j = min { C_i/W_i } (i=1,..,n)\)</p>

<pre><code class="language-text">public class WeightedLeastConnection {
    private List&lt;WeightedLeastConnectionServer&gt; servers;
    
    public WeightedLeastConnection() {
        this.servers = new ArrayList&lt;&gt;();
    }
    public void addServer(String ip, int weight) {
        this.servers.add(new WeightedLeastConnectionServer(ip, weight));
    }
    public WeightedLeastConnectionServer getServer() {
        WeightedLeastConnectionServer best = null;
        for (WeightedLeastConnectionServer srv : servers) {
            if(null ==  best || best.connCnt.get() / best.weight &gt; srv.connCnt.get() / srv.weight) {
                best = srv;
            }
        }
        best.connCnt.incrementAndGet();
        return best;
    }
    public void returnServer(WeightedLeastConnectionServer srv) {
        if (null != srv) {
            srv.connCnt.getAndAdd(-1);
        }
    }
    public static void main(String[] args) {
        WeightedLeastConnection wrr = new WeightedLeastConnection();
        wrr.addServer(&quot;10.1.1.1&quot;, 5);
        wrr.addServer(&quot;10.1.1.2&quot;, 3);
        wrr.addServer(&quot;10.1.1.3&quot;, 1);

        int cnt = 50;
        while(cnt &gt; 0) {
            System.out.println(wrr.getServer());
            cnt -= 1;
        }
    }
}

class WeightedLeastConnectionServer{
    String ip;
    int weight;
    AtomicInteger connCnt;

    public WeightedLeastConnectionServer(String ip, int weight) {
        this.ip = ip;
        this.weight = weight;
        this.connCnt = new AtomicInteger(0);
    }

    @Override
    public String toString() {
        return &quot;ip:&quot; + ip + &quot;, connection_cnt:&quot; + connCnt.get();
    }
}
</code></pre>

<h2 id="toc_4">Locality-Based Least-Connection Scheduling(基于局部性的最少链接调度)</h2>

<p>//todo</p>

<h2 id="toc_5">Locality-Based Least-Connection with Replication Scheduling</h2>

<p>(带复制的基于局部性最少链接调度)</p>

<h2 id="toc_6">Destination Hashing Scheduling(目标地址散列调度)</h2>

<p>//todo</p>

<h2 id="toc_7">Source Hashing Scheduling(源地址散列调度)</h2>

<p>//todo</p>

<h2 id="toc_8">Shortest Expected Delay Scheduling(最短的期望延迟)</h2>

<p>//todo</p>

<h2 id="toc_9">Never Queue Scheduling(最少队列调度)</h2>

<p>//todo</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS & HAPROXY & NGINX]]></title>
    <link href="fengbo.cool/LVS-HAPROXY-NGINX.html"/>
    <updated>2019-05-12T15:03:04+08:00</updated>
    <id>fengbo.cool/LVS-HAPROXY-NGINX.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">LVS</th>
<th style="text-align: center">HAPROXY</th>
<th style="text-align: center">NGINX</th>
<th style="text-align: center">F5</th>
<th style="text-align: center">ARRAY</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">出品方</td>
<td style="text-align: center">Linux</td>
<td style="text-align: center">Willy Tarreau</td>
<td style="text-align: center">Igor Sysoev</td>
<td style="text-align: center">F5 Networks</td>
<td style="text-align: center">Array Networks</td>
</tr>
<tr>
<td style="text-align: center">负载原理</td>
<td style="text-align: center">软件L4</td>
<td style="text-align: center">软件L7</td>
<td style="text-align: center">软件L7</td>
<td style="text-align: center">硬件L4~L7</td>
<td style="text-align: center">硬件L4~L7</td>
</tr>
<tr>
<td style="text-align: center">稳定性</td>
<td style="text-align: center">集成到Linux内核，自带keepalived双机热备</td>
<td style="text-align: center">可做keepalived双机热备</td>
<td style="text-align: center">C10K级别，可做keepalived双机热备</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">性能</td>
<td style="text-align: center">比硬件低，在软负载中数一数二</td>
<td style="text-align: center">低于LVS，高于Nginx</td>
<td style="text-align: center">高</td>
<td style="text-align: center">很高</td>
<td style="text-align: center">很高</td>
</tr>
<tr>
<td style="text-align: center">功能性</td>
<td style="text-align: center">支持大部分协议，所以支持基本上所有应用，例如WEB/数据库/中间件等</td>
<td style="text-align: center">TCP/HTTP/HTTPS/EMAIL</td>
<td style="text-align: center">HTTP/HTTPS/EMAIL</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">配置</td>
<td style="text-align: center">配置复杂，对网络要求较高</td>
<td style="text-align: center"></td>
<td style="text-align: center">简单</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">算法支持</td>
<td style="text-align: center">Round-robin(轮询)，Weight-round-robin(带权轮询)、Least-Connection(最小连接)、Weighte-Least-Connection(带权最小连接)</td>
<td style="text-align: center">Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求URL）、rdp-cookie（根据cookie）</td>
<td style="text-align: center">Round-robin（轮循）、Weight-round-robin（带权轮循）、Ip-hash（Ip哈希）</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">缺点</td>
<td style="text-align: center">不支持正则处理，不能做动静分离， 大规模网站实施起来很复杂</td>
<td style="text-align: center">不能做Web服务器即Cache</td>
<td style="text-align: center">支持协议较少</td>
<td style="text-align: center">贵</td>
<td style="text-align: center">贵</td>
</tr>
<tr>
<td style="text-align: center">其他优点</td>
<td style="text-align: center">配置性低(优点稳定)</td>
<td style="text-align: center">支持虚拟主机，session保持，cookie引导，支持TCP负载均衡</td>
<td style="text-align: center">可做反向代理服务器，正则规则灵活，服务器状态检测，缓存，静态网页/图片服务器，功能丰富</td>
<td style="text-align: center">应用交付/支持完善</td>
<td style="text-align: center">应用交付/支持完善</td>
</tr>
<tr>
<td style="text-align: center">适用场景</td>
<td style="text-align: center">大规模应用</td>
<td style="text-align: center">性能稍强于Nginx，适用于小规模应用</td>
<td style="text-align: center">小规模应用，日PV小于1000w</td>
<td style="text-align: center">大规模应用</td>
<td style="text-align: center">大规模应用</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于学习]]></title>
    <link href="fengbo.cool/how-to-learn.html"/>
    <updated>2019-05-12T14:32:13+08:00</updated>
    <id>fengbo.cool/how-to-learn.html</id>
    <content type="html"><![CDATA[
<p>最近经常和同事朋友们说起学习的问题，作为一个成年人来说，不可否认现在知识爆炸的时代很多人都迷失在了各种信息和诱惑当中，小时候的好奇心或许丢了大半，对信息的敏感程度也下降了，前段时间看了谢霆锋在谷歌香港的演讲，当中也说到了这个问题：</p>

<blockquote>
<p>But unknowingly, unknowingly we are so almost too inspired to a point where we are losing ourselves, because we are taking in everybody else&#39;s ideas -- their thoughts, their voices. Therefore, if we are not creative enough, we tend to what we call -- we would ride on other people&#39;s ideas. let&#39;s twist, let&#39;s tweak ..., but when we get into a habit of that... start of out own ideas...</p>
</blockquote>

<p>要有自己的idea， 这是最重要的.</p>

<h2 id="toc_0">成年人&amp;小朋友</h2>

<p>成年人学习和小朋友学习是不一样的。<br/>
小朋友刚出生不久，嗷嗷待哺，对万事万物都充满好奇，他们学习是兴趣，是好奇心，是真的汲取各种知识。成年人学习内在的驱动力不完全是好奇心，可能是事业，是成长的压力等，所以成年人学习更多的是一种刻意练习，并且在这个过程中掌握良好的学习方法。</p>

<h2 id="toc_1">学习新东西</h2>

<p>成年人学习新东西大概有三种目的：</p>

<ul>
<li>兴趣和爱好</li>
<li>是否有实用价值，优先级如何</li>
<li>培养阅读或者学习习惯</li>
</ul>

<h2 id="toc_2">如何学习？</h2>

<p>技术上来说的话，大概也可以分为三点：</p>

<ul>
<li>学习用法/用途，了解要解决的问题是什么</li>
<li>了解核心算法，核心思想</li>
<li>如何实现以及周边设施等等 (可选)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kafka In BigData]]></title>
    <link href="fengbo.cool/kafka-in-bigdata.html"/>
    <updated>2019-05-07T00:27:31+08:00</updated>
    <id>fengbo.cool/kafka-in-bigdata.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMq Delay Queue]]></title>
    <link href="fengbo.cool/RabbitMq-delay-queue.html"/>
    <updated>2019-05-07T00:26:44+08:00</updated>
    <id>fengbo.cool/RabbitMq-delay-queue.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集合竞价/连续竞价/实时股价]]></title>
    <link href="fengbo.cool/stock-starter.html"/>
    <updated>2019-04-20T18:37:45+08:00</updated>
    <id>fengbo.cool/stock-starter.html</id>
    <content type="html"><![CDATA[
<p>最近对股票比较感兴趣，主要是觉得工作之余也应该去研究下自己感兴趣的一些事情，例如最近在买股票，虽然只是上下班的时候看一下，都是全凭运气玩玩，但是看着看着就对股票运作的机制产生了疑问，股价是如何定义的呢？ 为什么会有股票这种东西呢等等，周末的时候也是看了一些资料，主要是了解了一下股价形成的原理，所以觉得虽然并不能让人赚钱，但是能解释自己在卖股票的时候看到的一些现象，也算是学到了一点知识吧。</p>

<h2 id="toc_0">集合竞价</h2>

<p>一直对股市开盘价是怎么确定的有很浓厚的兴趣，最近总算是了解一点了。<br/>
A股现在是9点半开盘，但其实买与卖在9点半之前就已经开始了， 具体是在9点15到9点半，存在一个<code>集合竞价</code>的阶段，这一阶段会决定9点半时候一只股票的开盘价。<br/>
集合竞价阶段的原则是<code>价格优先，时间优先</code>，价格优先的意思可以理解为当想要买入时使用拍卖时候的逻辑，即出价高的优先，当想要卖出时使用竞标的逻辑，即出价低的优先； 例如A想买，B想卖， 那么从A的角度来讲A出价高自然在买家中优先级高，B出价低自然在其他卖家中优先级高，所以A和B的交易时首先被撮合的。时间优先的概念就比较简单了。那么出现一个问题就是如果A出的价格和B出的价格不一样的话会怎么样呢？在集合竞价阶段会最终按照上面买卖规则一直撮合下去的话最终在一个价格上面停止，直到无法撮合，这个最终的价格就是所有被撮合交易的最终成交价格，不管最一开始的出价是多少。</p>

<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价</th>
<th>数量（手）</th>
<th>序号</th>
<th>委托卖出价</th>
<th>数量（手）</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>3.80</td>
<td>2</td>
<td>—1</td>
<td>3.52</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>—2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3．65</td>
<td>4</td>
<td>—3</td>
<td>3．60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3．60</td>
<td>7</td>
<td>—4</td>
<td>3．6</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3．54</td>
<td>6</td>
<td>—5</td>
<td>3．70</td>
<td>6</td>
</tr>
</tbody>
</table>

<p>上面的表格是一个集合竞价的例子，最终的开盘价会定格在3.65元, <a href="https://wiki.mbalib.com/wiki/%E9%9B%86%E5%90%88%E7%AB%9E%E4%BB%B7%E4%BA%A4%E6%98%93%E5%88%B6%E5%BA%A6">wiki</a></p>

<h2 id="toc_1">连续竞价</h2>

<p>集合竞价结束之后，没有撮合撮合的交易自动进入连续竞价的阶段，那么此时交易系统中可能会存在一些没有撮合的交易，在连续竞价阶段，当一个买入申请或者一个卖出申请进来时,有几种情况可能会发生:<br/>
1）如果没有对应的卖出或者买入申请，那么申请放入池中，等待撮合<br/>
2）如果买入申请低于最低的卖出申请的价格，那么买入申请放入池中，等待撮合<br/>
3）如果卖出申请高于最高的买入申请的价格，那么卖出申请放入池中，等待撮合，以上是三种无法撮合的情况<br/>
4）如果买入申请是当前最高价，且价格大于等于当前最低卖出价格，那么有两种情况：<br/>
    a）两者价格相等，那么直接成交<br/>
    b）买入价格大于卖出价格，那么以最低的卖出价格成交（类似于企业招标，价低者得）<br/>
5）如果卖出申请价格是当前最低价格，且价格小于等于当前最高买入价格，那么有两种情况：<br/>
    a）两者价格相等，那么直接成交<br/>
    b）卖出申请价格小于最高买入价格，那么以最高的买入价格成交（类似于拍卖拍卖，价高者得）<br/>
以上也是我们有时候看到自己会以比出价低的价格买到股票或者以比出价高的价格卖出股票的原因，本质上股票交易时结合了竞标和拍卖两种模型。</p>

<h2 id="toc_2">实时股价</h2>

<p>实时股价即根据当前交易的最后一笔成交价格计算, 这便是我们看到的股票实时价格的计算方法。<br/>
所以我们看到的股价上升的原因是不断的有人出比最低卖出价格高的价格买入股票，导致最低卖出价格不断上升，所以买入成交价不断上升；而股价下跌则是因为有人不断的以越来越低的价格抛售股票，这时候买入价格也会跟着降低，最终成交价格降低，导致股价下跌。</p>

<h2 id="toc_3">为什么会有人买卖股票呢？</h2>

<p>我很多时候会想，股票不是一种债务，仅仅代表一种权益，在以前，股票是有分红的，这也是它的价值所在，但现在A股分红是要除权的，看上去不仅不会带来收益，反而会因为交税等费用是的总体的估值降低。那么为什么会有这么多人买卖股票呢？我有时候就会想为什么人会买卖这种虚无的东西，虽然我们买卖股票是看得见价格的，我们也可以随时卖出套现，但是股票这种东西它的价值根基在什么地方呢？ 如果连最基本的立足点都没有，那股票的存在有什么意义呢？后来我想到了几个关键词:<code>流动性</code>，<code>供求关系</code>, <code>买卖</code>， 对于我这种经济学小白这几个词其实冲击蛮大的，有时候并不需要实实在在的资产，有了流动性，就是产生溢价，就会存在供求关系，买卖就自然而然的发生了， 所以炒股，精髓还是在于<code>炒</code>上面，想想也是挺奇葩的，经济学确实牛逼啊。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个JDK的Bug与NMT]]></title>
    <link href="fengbo.cool/java-nmt.html"/>
    <updated>2019-04-16T08:31:16+08:00</updated>
    <id>fengbo.cool/java-nmt.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">问题复现</h1>

<pre><code class="language-text">import java.util.UUID;
import java.util.concurrent.locks.LockSupport;

public class StringInterner {
    public static volatile String lastString;

    public static void main(String[] args) {
        for (int iterations = 0; iterations &lt; 40;) {
            String baseName = UUID.randomUUID().toString();
            for (int i = 0; i &lt; 1_000_000; i++) {
                lastString = (baseName + i).intern();
            }
            if (++iterations % 10 == 0) {
                System.gc();
            }
            LockSupport.parkNanos(500_000_000);
        }
    }
}
</code></pre>

<p>将代码编译(javac)打包(jar)后分别使用G1和CMS运行:</p>

<pre><code class="language-text">java -XX:NativeMemoryTracking=detail -XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics -XX:+UseG1GC -XX:MetaspaceSize=100m -XX:MaxMetaspaceSize=100m -Xloggc:gc-jdk8-g1.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms256m -Xmx256m -cp classes StringInterner
--&gt;
Symbol (reserved=360278KB, committed=360278KB)
                            (malloc=359758KB #44949) 
                            (arena=520KB #1)
</code></pre>

<pre><code class="language-text">java -XX:NativeMemoryTracking=detail -XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics -XX:MetaspaceSize=100m -XX:MaxMetaspaceSize=100m -XX:+UseStringDeduplication -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -Xloggc:gc-jdk8-marksweep.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms256m -Xmx256m -cp classes StringInterner
--&gt;
Symbol (reserved=20830KB, committed=20830KB)
                            (malloc=20310KB #2518) 
                            (arena=520KB #1)
</code></pre>

<p>上面的代码模拟了填充字符串缓存池的过程, 这里引出了java8(1.8.0_144-b01可复现,具体可见<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8180048">Bug描述</a>和<a href="https://bugs.openjdk.java.net/browse/JDK-8180048">补丁进度</a>)中的一个G1垃圾收集器的bug:维护字符串缓冲区的数据结构内存泄漏(G1垃圾收集器)。</p>

<h1 id="toc_1">问题解释</h1>

<p>在java6时代，字符串缓存区是放在永久代也就是MetaSpace中的，并且是一个固定大小，因此在java6中应该谨慎使用<code>String.intern()</code>方法, 以免造成OOM;<br/>
java7以后，字符串缓存区移到了堆内存中，同时可以进行垃圾回收。<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8180048">原文见:</a></p>

<blockquote>
<p>the issue is that some C++ helper data structure for managing the interned string list leaks in G1; it is shown in the &quot;Symbol&quot; category in NMT output, but that has nothing to do with Metaspace.</p>
</blockquote>

<h1 id="toc_2">NMT</h1>

<p>NMT = Native Memory Tracking 本地内存跟踪<br/>
NMT是Java HotSpot VM提供的跟踪内部内存使用的工具，结合jcmd命令可以在不同级别上分析内存的使用, NMT的关键特性有:</p>

<ul>
<li>NMT默认在HotSpot上是关闭的，要打开需要使用<code>-XX:NativeMemoryTracking=summary</code> 或者<code>-XX:NativeMemoryTracking=detail</code></li>
<li>内存跟踪数据可以使用jcmd命令查看，具体用法<code>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</code></li>
<li>NMT可以生成汇总和明细内存数据</li>
<li>建立内存基线方便后面进行对比</li>
<li>JVM退出时可以输出内存使用报告, 具体用法<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics</code></li>
<li>NMT可以使用jcmd工具关闭，但无法start或者restart</li>
<li>NMT无法跟踪非java代码分配的内存，例如native方法</li>
</ul>

<h2 id="toc_3">使用NMT检测内存泄漏</h2>

<ul>
<li>开启NMT , <code>-XX:NativeMemoryTracking=summary</code> 或者<code>-XX:NativeMemoryTracking=detail</code></li>
<li>使用<code>jcmd &lt;pid&gt; VM.native_memory baseline</code>建立内存基线</li>
<li>使用<code>jcmd &lt;pid&gt; VM.native_memory detail.diff</code>检测内存变化</li>
<li>如果内存泄漏比较缓慢，那么需要多等待一会儿</li>
</ul>

<h2 id="toc_4">读懂NMT输出的数据</h2>

<p>下表展示了NMT的的内存分类</p>

<table>
<thead>
<tr>
<th>Category</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Java Heap</td>
<td>堆</td>
</tr>
<tr>
<td>Class</td>
<td>类元数据</td>
</tr>
<tr>
<td>Code</td>
<td>代码</td>
</tr>
<tr>
<td>GC</td>
<td>GC使用的数据，例如卡表</td>
</tr>
<tr>
<td>Compiler</td>
<td>编译器生成代码使用的内存</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号，例如变量名</td>
</tr>
<tr>
<td>Memory Tracking</td>
<td>NMT</td>
</tr>
<tr>
<td>Pooled Free Chunks</td>
<td>Arena内存块池使用</td>
</tr>
<tr>
<td>Shared space for classes</td>
<td>类共享存档映射的内存</td>
</tr>
<tr>
<td>Thread</td>
<td>线程使用，包括线程数据结构，资源区和句柄区</td>
</tr>
<tr>
<td>Thread stack</td>
<td>线程堆栈,被标记为已提交</td>
</tr>
<tr>
<td>Internal</td>
<td>不在以上类别，例如命令行解释器</td>
</tr>
<tr>
<td>Unknown</td>
<td>无法确定的内存</td>
</tr>
</tbody>
</table>

<hr/>

<h3 id="toc_5">准备知识</h3>

<p><code>committed</code>已提交内存是实际使用的,例如<code>-Xms100m -Xmx1000m</code>，那么jvm会<code>reserve 1000MB</code>，因为初始内存为<code>100MB</code>， 因此<code>committed 100MB</code><br/>
<code>Arena</code>是一块使用<code>malloc</code>分配出来的内存。当退出范围或离开代码区域时，内存会从这些块中大量释放。这些块可以在其他子系统中重用，以保存临时内存，例如线程前分配。Arena malloc策略确保没有内存泄漏。因此Arena是作为一个整体而不是单个对象进行跟踪的。某些初始内存无法被跟踪。<br/>
需要注意的是启用NMT会降低机器5%到10%的性能，并且会带来内存使用的提升，因为NMT会在每个<code>malloc</code>的内存头部添加<code>2 machine words</code>作为<code>malloc header</code>, NMT使用的内存也会被NMT追踪。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html">文档</a>原话如下:</p>

<blockquote>
<p>Enabling NMT will result in a 5-10 percent JVM performance drop and memory usage for NMT adds 2 machine words to all malloc memory as malloc header. NMT memory usage is also tracked by NMT.</p>
</blockquote>

<hr/>

<h3 id="toc_6">NMT汇总数据</h3>

<p>使用NMT追踪内存分配汇总数据需要使用<code>-XX:NativeMemoryTracking=summary</code>开启<br/>
然后使用<code>jcmd &lt;pid&gt; VM.native_memory summary</code>打印汇总数据，样例如下:</p>

<pre><code class="language-text">Total:  reserved=664192KB,  committed=253120KB                                           &lt;--- NMT追踪的总内存
 
-                 Java Heap (reserved=516096KB, committed=204800KB)                      &lt;--- 堆内存
                            (mmap: reserved=516096KB, committed=204800KB)
 
-                     Class (reserved=6568KB, committed=4140KB)                          &lt;--- 类的元数据
                            (classes #665)                                               &lt;--- 类加载数 665
                            (malloc=424KB, #1000)                                        &lt;--- malloc分配的内存大小，malloc数1000
                            (mmap: reserved=6144KB, committed=3716KB)
 
-                    Thread (reserved=6868KB, committed=6868KB)
                            (thread #15)                                                 &lt;--- 线程数
                            (stack: reserved=6780KB, committed=6780KB)                   &lt;--- 线程堆栈使用内存数
                            (malloc=27KB, #66)
                            (arena=61KB, #30)                                            &lt;--- 资源&amp;句柄
 
-                      Code (reserved=102414KB, committed=6314KB)
                            (malloc=2574KB, #74316)
                            (mmap: reserved=99840KB, committed=3740KB)
 
-                        GC (reserved=26154KB, committed=24938KB)
                            (malloc=486KB, #110)
                            (mmap: reserved=25668KB, committed=24452KB)
 
-                  Compiler (reserved=106KB, committed=106KB)
                            (malloc=7KB, #90)
                            (arena=99KB, #3)
 
-                  Internal (reserved=586KB, committed=554KB)
                            (malloc=554KB, #1677)
                            (mmap: reserved=32KB, committed=0KB)
 
-                    Symbol (reserved=906KB, committed=906KB)
                            (malloc=514KB, #2736)
                            (arena=392KB, #1)
 
-           Memory Tracking (reserved=3184KB, committed=3184KB)
                            (malloc=3184KB, #300)
 
-        Pooled Free Chunks (reserved=1276KB, committed=1276KB)
                            (malloc=1276KB)
 
-                   Unknown (reserved=33KB, committed=33KB)
                            (arena=33KB, #1)
</code></pre>

<hr/>

<h3 id="toc_7">NMT明细数据</h3>

<p>使用<code>-XX:NativeMemoryTracking=detail</code>开启明细追踪，NMT会追踪分配内存最多的几个方法，然后使用<code>jcmd &lt;pid&gt; VM.native_memory detail</code>打印明细数据，样例如下:</p>

<pre><code class="language-text">Virtual memory map:
 
[0x8f1c1000 - 0x8f467000] reserved 2712KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0x8f1c1000 - 0x8f467000] committed 2712KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x8f585000 - 0x8f729000] reserved 1680KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0x8f585000 - 0x8f729000] committed 1680KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x8f930000 - 0x90100000] reserved 8000KB for GC
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0x8f930000 - 0x90100000] committed 8000KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
 
[0x902dd000 - 0x9127d000] reserved 16000KB for GC
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0x902dd000 - 0x9127d000] committed 16000KB from [os::pd_commit_memory(char*, unsigned int, unsigned int, bool)+0x36]
 
[0x9127d000 - 0x91400000] reserved 1548KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0x9127d000 - 0x91400000] committed 1548KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x91400000 - 0xb0c00000] reserved 516096KB for Java Heap                                                                            &lt;--- 保留的内存地址范围
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x190]                  &lt;--- 保留内存的方法调用(callsite)
        [0x91400000 - 0x93400000] committed 32768KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x3e8]               &lt;--- 已提交的内存以及方法调用
        [0xa6400000 - 0xb0c00000] committed 172032KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
 
[0xb0c61000 - 0xb0ce2000] reserved 516KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0xb0c61000 - 0xb0ce2000] committed 516KB from [Thread::record_stack_base_and_size()+0xca]
 
[0xb0ce2000 - 0xb0e83000] reserved 1668KB for GC
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0xb0ce2000 - 0xb0cf0000] committed 56KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
        [0xb0d88000 - 0xb0d96000] committed 56KB from [CardTableModRefBS::resize_covered_region(MemRegion)+0xebf]
        [0xb0e2e000 - 0xb0e83000] committed 340KB from [CardTableModRefBS::resize_covered_region(MemRegion)+0xebf]
 
[0xb0e83000 - 0xb7003000] reserved 99840KB for Code
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0xb0e83000 - 0xb0e92000] committed 60KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x3e8]
        [0xb1003000 - 0xb139b000] committed 3680KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x37a]
 
[0xb7003000 - 0xb7603000] reserved 6144KB for Class
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0xb7003000 - 0xb73a4000] committed 3716KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x37a]
 
[0xb7603000 - 0xb760b000] reserved 32KB for Internal
                from [PerfMemory::create_memory_region(unsigned int)+0x8ba]
 
[0xb770b000 - 0xb775c000] reserved 324KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0xb770b000 - 0xb775c000] committed 324KB from [Thread::record_stack_base_and_size()+0xca]
</code></pre>

<hr/>

<h3 id="toc_8">NMT内存基线以及对比</h3>

<p>开启汇总或者明细追踪，然后使用<code>jcmd &lt;pid&gt; VM.native_memory baseline</code>建立内存基线，然后预热应用，然后使用<code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 或者 <code>jcmd &lt;pid&gt; VM.native_memory detail.diff</code>打印内存变化的情况,<br/>
汇总样例如下:</p>

<pre><code class="language-text">Total:  reserved=664624KB  -20610KB, committed=254344KB -20610KB                         &lt;--- 总内存与基线对比. &#39;+&#39;=增加 &#39;-&#39;=减少
 
-                 Java Heap (reserved=516096KB, committed=204800KB)
                            (mmap: reserved=516096KB, committed=204800KB)
 
-                     Class (reserved=6578KB +3KB, committed=4530KB +3KB)
                            (classes #668 +3)                                            &lt;--- 新加载了3个类
                            (malloc=434KB +3KB, #930 -7)                                 &lt;--- malloc的内存新增了3KB,但malloc数量减少了7次
                            (mmap: reserved=6144KB, committed=4096KB)
 
-                    Thread (reserved=60KB -1129KB, committed=60KB -1129KB)
                            (thread #16 +1)                                              &lt;--- 新增了一个线程
                            (stack: reserved=7104KB +324KB, committed=7104KB +324KB)
                            (malloc=29KB +2KB, #70 +4)
                            (arena=31KB -1131KB, #32 +2)                                 &lt;--- 新增2块arena(多了一个资源区和一个句柄区)
 
-                      Code (reserved=102328KB +133KB, committed=6640KB +133KB)
                            (malloc=2488KB +133KB, #72694 +4287)
                            (mmap: reserved=99840KB, committed=4152KB)
 
-                        GC (reserved=26154KB, committed=24938KB)
                            (malloc=486KB, #110)
                            (mmap: reserved=25668KB, committed=24452KB)
 
-                  Compiler (reserved=106KB, committed=106KB)
                            (malloc=7KB, #93)
                            (arena=99KB, #3)
 
-                  Internal (reserved=590KB +35KB, committed=558KB +35KB)
                            (malloc=558KB +35KB, #1699 +20)
                            (mmap: reserved=32KB, committed=0KB)
 
-                    Symbol (reserved=911KB +5KB, committed=911KB +5KB)
                            (malloc=519KB +5KB, #2921 +180)
                            (arena=392KB, #1)
 
-           Memory Tracking (reserved=2073KB -887KB, committed=2073KB -887KB)
                            (malloc=2073KB -887KB, #84 -210)
 
-        Pooled Free Chunks (reserved=2624KB -15876KB, committed=2624KB -15876KB)
                            (malloc=2624KB -15876KB)
</code></pre>

<p>明细样例如下：</p>

<pre><code class="language-text">Details:
 
[0x01195652] ChunkPool::allocate(unsigned int)+0xe2
                            (malloc=482KB -481KB, #8 -8)
 
[0x01195652] ChunkPool::allocate(unsigned int)+0xe2
                            (malloc=2786KB -19742KB, #134 -618)
 
[0x013bd432] CodeBlob::set_oop_maps(OopMapSet*)+0xa2
                            (malloc=591KB +6KB, #681 +37)
 
[0x013c12b1] CodeBuffer::block_comment(int, char const*)+0x21                &lt;--- [方法调用地址] 方法名 + 偏移量
                            (malloc=562KB +33KB, #35940 +2125)               &lt;--- malloc大小增加33KB #malloc数增加2125
 
[0x0145f172] ConstantPool::ConstantPool(Array&lt;unsigned char&gt;*)+0x62
                            (malloc=69KB +2KB, #610 +15)
 
...
 
[0x01aa3ee2] Thread::allocate(unsigned int, bool, unsigned short)+0x122
                            (malloc=21KB +2KB, #13 +1)
 
[0x01aa73ca] Thread::record_stack_base_and_size()+0xca
                            (mmap: reserved=7104KB +324KB, committed=7104KB +324KB)
</code></pre>

<hr/>

<h3 id="toc_9">关闭NMT</h3>

<p><code>jcmd &lt;pid&gt; VM.native_memory shutdown</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMQ vs Kafka]]></title>
    <link href="fengbo.cool/RabbitMq-vs-Kafka.html"/>
    <updated>2019-04-12T20:59:04+08:00</updated>
    <id>fengbo.cool/RabbitMq-vs-Kafka.html</id>
    <content type="html"><![CDATA[
<p>RabbitMQ和Kafka是两种很经典的分布式消息中间件，这篇文章试着从设计理念，基础特性，适用场景几个方面来描述这两种中间件。</p>

<h2 id="toc_0">关于RabbitMq</h2>

<ul>
<li>Consumer</li>
<li>Publisher</li>
<li>Exchange: 消息交换</li>
<li>Route: 消息路由</li>
</ul>

<h2 id="toc_1">关于Kafka</h2>

<ul>
<li>Consumer,ConsumerGroup</li>
<li>Producer</li>
<li>Kafka source connect</li>
<li>Kafka sink connect</li>
<li>Topic and topic partition</li>
<li>Kafka stream</li>
<li>Broker</li>
<li>Zookeeper</li>
</ul>

<h2 id="toc_2">设计理念</h2>

<h2 id="toc_3">可扩展，分布式，可靠性是两个系统的共同特点。</h2>

<p>RabbitMq是经典的面向消息队列而设计的，它实现了AMQP协议。RabbitMq强大的地方在于它实现了高度灵活的消息路由功能，非常便于使用和拓展。<br/>
<img src="media/15550739440669/15558383060583.jpg" alt=""/></p>

<hr/>

<p>Kafka是一个分布式的提交日志，这个提交日志<code>(commit-log)</code>的概念上来说和数据库的没有区别：都能够记录数据的变化并且可以重放。但是和数据库不同的是数据库的日志用来做恢复用而在Kafka中日志是一等公民。Kafka中没有队列的概念，一开始可能会让人感觉到奇怪。但这也是它的优势所在。<br/>
<img src="media/15550739440669/15558631089848.jpg" alt=""/></p>

<hr/>

<p>从设计上来说，两者比较明显的一个区别是rabbitmq的中的消息是不进行持久化的，Kafka则相反(有淘汰策略)。因此Kafka支持多个消费者同时消费一个topic而互不影响，RabbitMq则不能做到多个消费者消费同一个队列而画像不受到影响(消费后即删除)。但RabbitMq的灵活的消息路由机制可以达到相同的目的。<br/>
另外RabbitMq是以队列(queue)为单位的。而Kafka是以分区(partition)为单位的。</p>

<h2 id="toc_4">PUB and SUB</h2>

<h2 id="toc_5">RabbitMq和Kafka都支持并发的消息生产和消费，但是两者各自的特性不同。</h2>

<p>RabbitMq和Kafka都支持基础的消息的发布功能，RabbitMq为了支持丰富的路由策略，因此生产者不是直接将消息发送到队列而是发送到Exchange中<code>Channel.basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body)</code>,然后根据exchange type和routingKey还有其他属性决定将消息发送到什么队列:</p>

<ul>
<li>exchange type = fanout, 广播模式，exchange会将消息广播到所有绑定到这个exchange的其他exchange和queue</li>
<li>exchange type = direct, 精确匹配, 根据消息的routingKey精确发送到和Exchange绑定的Queue(Queue申明绑定时同时指定routingkey)</li>
<li>exchange type = Topic , 模糊匹配，Queue绑定时可以指定正则，*代表任意字符, #代表任意数字</li>
<li>exchange type = Header, 消息头匹配，这种方式忽略routingKey，而是根据发送消息时指定的消息头匹配，同样队列绑定时也要指定消息头匹配规则</li>
<li>exchange type = Consistent Hashing, 一致性哈希，exchange根据routingKey, header, message properties 的哈希值将消息分布到不同的队列中去，这个特性提供了类似于Kafka中分区的功能</li>
<li>死信队列，队列可以配置条件(size,ttl等)将消息驱逐到指定的exchange中</li>
<li>其他例如临时类型(Ephemeral Exchanges)和优先类型(Priority Exchanges)</li>
</ul>

<p>从性能上来说，fanout的性能时最高的，不用做任何判断，direct性能差一点，需要精确匹配，Header最强大也性能也最差。<br/>
RabbitMq中一个队列可以有多个消费者，但一条消息只允许一个消费者消费，消费完之后会从队列中消除，提高吞吐量的方法是使用Push API;</p>

<hr/>

<p>Kafka的消息是持久化的，RabbitMq中的消息是会消亡的。因此类似于RabbitMq中的重新入队或者延迟对Kakfa来说没有意义，重新入队会造成消息顺序混乱和重复，Kafka也没有内置的延迟策略。<br/>
Kafka通过类似于<code>KafkaProducer.send(new ProducerRecord(topic, key, data))</code>的API将消息发送到指定主题和分区，如果采用默认的分区器，那么Kafka会对key进行散列，同一个key被发送到同一个分区，如果没有指定key，那么分区器将随机分配到某一个分区，另外也可以指定自定义的分区器，这取决于你想要怎么样的分区策略。<br/>
Kafka要对消息做持久化，那么是不是意味着Kafka消息生产的性能很低？并不是，Kafka使用操作系统缓冲区缓存消息，相当于每次都是操作内存，因此效率是非常高，另一方面Kafka在硬盘中的存储方式是顺序存储的，对于硬盘来说，数据寻址是性能消耗的主要原因之一，由于是顺序存储，Kafka在写入的时候顺序写入硬盘的效率比一般的写入效率高出很多。顺序存储的另一个好处是读取的效率很高，另外Kafka使用了零复制技术，意味着原本从文件系统-&gt;内核空间-&gt;用户空间-&gt;网卡通道要经过两次内存缓存区复制变成了直接从文件系统发送到网络通道，而不需要经过任何内存缓存区，避免了字节复制，从而提高了性能。<br/>
Kafka中的消息持久化使得各个消费者可以同时消费而互不影响，Kafka中的消费群组保证了同一条消息只被其中一个消费者消费（再均衡的情况下可能发生重复消费）。</p>

<h2 id="toc_6">PULL or PUSH</h2>

<h2 id="toc_7">RabbitMq使用推模型，而Kafka使用拉模型。</h2>

<p>RabbitMq使用的是推送模型（push)，同时通过设置<code>prefetch limit</code>预取值来防止生产速度大于消费速度，这样做的好处是消息延迟低并且也很适合基于队列的消息架构。<br/>
但其实RabbitMq也支持拉API, 从Spring-AMQP的实现来讲，Push API使用Listner Container并且注册回调函数， 然后Pull API使用的是Channel.basicGet。</p>

<hr/>

<p>Kafka使用的拉模型（pull），消费者从给定的偏移量开始批量请求消息。为了防止无意义的请求轮询，Kakfa允许长轮询（long-polling）。<br/>
由于分区的设计，Kafka使用拉模型是比较合理的，使用推模型的话就不灵活了。由于Kafka消息的消费没有竞争，所以通过批量获取消息可以达到很高的吞吐量。对于RabbitMq来说这么做没有太大的意义因为希望尽快的分配一个消息并且完成处理。</p>

<h2 id="toc_8">消息投递保证</h2>

<ul>
<li><code>最多一次</code> :意味着消息不会重复投递但是可能丢失(RabbitMq &amp; Kafka)</li>
<li><code>最少一次</code> :意味着消息不会丢失但可能重复投递，意味着消息可能被成功处理两次(RabbitMq &amp; Kafka)</li>
<li><code>精确一次</code> :消息系统的皇冠，准确投递一次(Kafka在很有限的情况下满足)</li>
</ul>

<hr/>

<p>消息系统可以简单的抽象化为两个组件:生产者和消费者, 不管是消息的生产还是消费都离不开这两种角色:<br/>
<img src="media/15550739440669/15570192785099.jpg" alt="" style="width:362px;"/></p>

<p>正常情况下，为了保证消息成功消费，生产者和消费者会进行两次通信：发送消息和确认消费，那么其中有四个地方可能会发生中断或者失败(网络原因/bug/故障等等)。<br/>
在看相关的资料之前，我很疑惑这种投递保证要保证的究竟是什么？指的是消息发送还是处理成功的次数？如果四个步骤中发生了问题应该如何处理？ 在send和process阶段如果出错，那么重发消息是正确的， 如果是response和ack阶段出错那就不应该再重发，kafka保证的exactly once究竟是怎么做到的呢？看了资料之后才有了大概的理解。<br/>
首先，消息投递的保证从结果来看比较好理解一点，最多一次(at-most-once), 最少一次(at-least-once)都不能保证除了问题之后消息处理的结果不会发生变化，精确一次(exactly-once)就可以做到正常情况下和出了问题的情况下消息的处理结果还是一样的，例如消息计数。</p>

<blockquote>
<p>the result of computaion -- including all state changes -- is the same if the error occurs during processing or not.</p>
</blockquote>

<p>那么其实不难看出，无论生产者和消费者的组件如何设计，一般情况下都存在某个阶段需要用户代码参与，此时exactly-once的保证是极难达成的，因为用户代码的幂等性无法保证，所以从结果来看，完成精确一次的保证是需要生产者和消费者之间步伐完全统一的，那么kafka是如何做到这一点的呢？其实kafka所说的exactly-once保证也只在它的stream api和producer中有，再producer中，kafka为每个消息附加一个唯一的id，这样保证消息不会被重复处理。stream api的场景是几个topic的结果处理后输出到另一个topic，在可以掌控输入和输出端的情况下做到了exactly-once的保证(<a href="https://www.youtube.com/watch?v=JPcT1GGzszA">Exactly-Once Semantics in Apache Kafka</a>)</p>

<h2 id="toc_9">消息排序</h2>

<h2 id="toc_10">Kafka和RabbitMq都能保证消息的顺序</h2>

<p>具体情况是两者在单线程情况下都能保证在队列和分区中的消息的顺序是和发送顺序一样的。这很好理解，因为在多线程的情况下的顺序是很难定义的，而kafka中还有分区的概念。</p>

<h2 id="toc_11">高可用&amp;容错</h2>

<h2 id="toc_12">Kafka和RabbitMq都有良好的高可用机制。例如分区副本，镜像队列，消息和元数据持久化等等。</h2>

<p>分布式系统总是离不开可用性和一致性的问题，CAP理论是其中的一个代表, <a href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed">CAP理论十二年回顾：&quot;规则&quot;变了</a><br/>
正如前文提到的， Kafka是一个分布式的提交日志，所以是对消息做了持久化，另外Kafka会对Topic以及Partition做多副本。另外Kafka使用ZK保存集群的元数据信息和消费者的信息。<br/>
RabbitMq中存在镜像队列的概念，即存在一主多从的队列，所有操作会在镜像队列中重放，保证队列的高可用，另外元数据信息使用的是内置的<a href="https://zh.wikipedia.org/wiki/Mnesia">Mnesia</a>数据库.</p>

<h2 id="toc_13">使用场景</h2>

<h2 id="toc_14">RabbitMq适用于低延迟的业务处理系统，Kafka使用与高吞吐的流处理系统。</h2>

<p>RabbitMq的Push API的延迟较低，但相对于Kafka对于吞吐的优化而言，RabbitMq的吞吐没有那么高，并且由于低延迟所以适合于业务相关的消息处理，例如交易支付等。Kafka由于其Pull API和高吞吐设计，比较适用于数据仓库类的流计算处理，但若业务系统对于持久化的需求很强烈，那么采用Kafka也是很好的选择。</p>

<h1 id="toc_15">总结</h1>

<p>水平有限, 仅限参考。</p>

<h1 id="toc_16">Refer</h1>

<p><a href="https://jack-vanlightly.com/blog/2017/12/4/rabbitmq-vs-kafka-part-1-messaging-topologies">rabbitmq-vs-kafka-part-1-messaging-topologies</a><br/>
<a href="https://jack-vanlightly.com/blog/2017/12/5/rabbitmq-vs-kafka-part-2-rabbitmq-messaging-patterns-and-topologies">rabbitmq-vs-kafka-part-2-rabbitmq-messaging-patterns-and-topologies</a><br/>
<a href="https://jack-vanlightly.com/blog/2017/12/8/rabbitmq-vs-kafka-part-3-kafka-messaging-patterns">rabbitmq-vs-kafka-part-3-kafka-messaging-patterns</a><br/>
<a href="https://jack-vanlightly.com/blog/2017/12/15/rabbitmq-vs-kafka-part-4-message-delivery-semantics-and-guarantees">rabbitmq-vs-kafka-part-4-message-delivery-semantics-and-guarantees</a><br/>
<a href="https://jack-vanlightly.com/blog/2018/8/31/rabbitmq-vs-kafka-part-5-fault-tolerance-and-high-availability-with-rabbitmq">rabbitmq-vs-kafka-part-5-fault-tolerance-and-high-availability-with-rabbitmq</a><br/>
<a href="https://jack-vanlightly.com/blog/2018/9/2/rabbitmq-vs-kafka-part-6-fault-tolerance-and-high-availability-with-kafka">rabbitmq-vs-kafka-part-6-fault-tolerance-and-high-availability-with-kafka</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次maven缓存引发的血案]]></title>
    <link href="fengbo.cool/20190328-mvn-messed.html"/>
    <updated>2019-03-28T00:23:24+08:00</updated>
    <id>fengbo.cool/20190328-mvn-messed.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">现象</h2>

<p>Back发布后，Back-yp发布失败 (Back-yp 依赖Back)<br/>
报错信息为:<br/>
<img src="media/15537038043202/15537039791960.jpg" alt="" style="width:1215px;"/><br/>
错误信息大意是依赖的Back中依赖的中转中心的包少了一个枚举对象,<br/>
以下中转中心使用trans代替</p>

<h2 id="toc_1">排查</h2>

<ul>
<li>首先排查了back-yp应用中实际使用到的Back和Trans的版本，依次是1.2.1和1.0.40,<br/>
然后Back中的1.2.1是有新加代码的(版本号未升级), 而对应的Trans的1.0.40的代码是老的代码. 而且理论上Back中1.2.1的代码是mvn私服的release版本，所以理论上不应该有新的代码。</li>
<li>由于我们在打包环境上打包，然后会使用到mvn本地缓存，所以我们看了mvn本地缓存的情况，Back 1.2.1的代码确实已经变了，然后对应依赖的Trans的版本是test-SNAPSHOT</li>
<li>查找资料发现mvn install会更新本地的mvn缓存， 即Back的1.2.1的本地缓存，然后Back-yp打包的时候使用了本地缓存，从而有了新代码，然后理论上Trans的版本应该也改变成为test-SNAPSHOT，怎么会是1.0.40呢 ？ 既不是test-SNAPSHOT, 也不是1.0.10(Back 1.2.1实际依赖的Trans版本)</li>
<li>看来除了mvn install的错误之外，还存在其他的问题, 否则不应该出现错误，除非代码向后不兼容。<br/>
于是问题变成了如图:
<img src="media/15537038043202/15537041212073.jpg" alt=""/></li>
</ul>

<h2 id="toc_2">结果</h2>

<p>经过排查，Back-yp中还有一个依赖Saint.bundle也引用了Trans,版本正式1.0.40, 由于两个Trans版本发生了冲突，mvn选择了1.0.40, 加上mvn install更新了本地缓存，导致了问题的发生</p>

<h2 id="toc_3">解决方案</h2>

<ol>
<li> Mvn install停用， 使用mvn package， 不覆盖本地缓存， 使用私服上面的发行版本</li>
<li> 解决Back-yp中的Trans版本冲突，使用一个前置的统一版本</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JtableSaw-Pandas]]></title>
    <link href="fengbo.cool/project-tablesaw-pandas.html"/>
    <updated>2019-03-17T23:48:21+08:00</updated>
    <id>fengbo.cool/project-tablesaw-pandas.html</id>
    <content type="html"><![CDATA[
<p>项目fork于JtableSaw</p>

<h2 id="toc_0">目标</h2>

<ul>
<li>封装pandas-like API, 但是由于java缺少python中运算符重载的能力，所以不完全</li>
<li>添加新的API</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Canal-Rabbit]]></title>
    <link href="fengbo.cool/project-canal-rabbit.html"/>
    <updated>2019-03-17T23:48:12+08:00</updated>
    <id>fengbo.cool/project-canal-rabbit.html</id>
    <content type="html"><![CDATA[
<p>Canal原生支持接入RabbitMq</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zwift促销代码]]></title>
    <link href="fengbo.cool/zwift-promo-codes.html"/>
    <updated>2019-03-17T23:31:03+08:00</updated>
    <id>fengbo.cool/zwift-promo-codes.html</id>
    <content type="html"><![CDATA[
<p>在游戏界面键入<code>p</code>然后输入代码即可解锁不同套装</p>

<table border="0" cellpadding="0" cellspacing="0" width="479" style="border-collapse:
 collapse;width:359pt">
<!--StartFragment-->
 <colgroup><col width="196" span="2" style="mso-width-source:userset;mso-width-alt:6272;
 width:147pt" />
 <col width="87" style="width:65pt" />
 </colgroup><tbody><tr height="21" style="height:16.0pt">
  <td height="21" class="xl64" align="left" width="196" style="height:16.0pt;
  width:147pt">1-18</td>
  <td class="xl63" align="left" width="196" style="width:147pt">19-36</td>
  <td class="xl63" align="left" width="87" style="width:65pt">37-53</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">ATOC2015</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOLDCOAST</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">PCGKIT32516</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">BICYCLINGMAG</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOLONGRIDERS</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">RADAVIST</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">BIKEANDBEER</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOPEARSON</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">RIDEAUSTRALIA</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">BIKERADAR</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOSKRYE</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">RIDEPOWERTAP</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">CANBERRACCKIT</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOTACX</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">RIDEQUARQ</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">CRCANYC</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOTRAINSHARP</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">ROAD.CC</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">DOCOMO</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOUSMES</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">SIGMASPORT</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GEARPATROL</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOVISION</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">SLOWTWITCH</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GEELONGCCKIT</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOWBR</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">SOIGNEURDK</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOALIENWARE</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">GOWSR</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">STKILDA2015KIT</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOAMGENTOC</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">HIKKIT32616</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">SYDNEYCCKIT</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOBATTENKILL</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">JENSIE</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">TDP2015</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOCIS</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">LAFUGA.CC</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">TRIATHLETEMAG</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOCYCLEOPS</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">LAVA</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">TSBIKES</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOELITE</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">MDCCKIT</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">VCGHKIT</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOFREESPEED</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">MGCCKIT</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">WAHOOFITNESS</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">GOGCN</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">MTSKIT</td>
  <td align="left" style="background-color:rgba(255, 255, 255, 0.8)">ZTHKIT</td>
 </tr>
 <tr height="21" style="height:16.0pt;background-color:rgba(255, 255, 255, 0.8)">
  <td height="21" align="left" style="height:16.0pt;font-variant-ligatures: normal;
  font-variant-caps: normal;font-variant-numeric: inherit;font-variant-east-asian: inherit;
  font-stretch: inherit;line-height:inherit;background-color:rgba(255, 255, 255, 0.8);
  orphans: 2;widows: 2;-webkit-text-stroke-width: 0px;text-decoration-style: initial;
  text-decoration-color: initial">GOINGAMBA</td>
  <td align="left" style="font-variant-ligatures: normal;font-variant-caps: normal;
  font-variant-numeric: inherit;font-variant-east-asian: inherit;font-stretch: inherit;
  line-height:inherit;background-color:rgba(255, 255, 255, 0.8);orphans: 2;
  widows: 2;-webkit-text-stroke-width: 0px;text-decoration-style: initial;
  text-decoration-color: initial">NCCMAKIT</td>
  <td></td>
 </tr>
<!--EndFragment-->
</tbody></table>

<h1 id="toc_0">source</h1>

<p><a href="https://www.reddit.com/r/Zwift/comments/84m4te/list_of_zwift_kit_promo_codes/">zwift-promo-code</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库事务隔离级别引发的血案]]></title>
    <link href="fengbo.cool/isolation-problem.html"/>
    <updated>2019-03-17T22:24:06+08:00</updated>
    <id>fengbo.cool/isolation-problem.html</id>
    <content type="html"><![CDATA[
<p>生产环境中有一台实时监控数据库binlog日志的应用，用于数据的实时统计等。 <br/>
由于用来读取数据的库和线上主库是主从关系，因此存在在一定的延迟。<br/>
生产环境中，由于延迟的存在，有时候实时消息依赖的数据可能不会马上能够获取到。<br/>
<img src="media/15528326468637/15528340979248.jpg" alt="" style="width:1183px;"/><br/>
有时候延迟还是比较恐怖的.</p>

<h2 id="toc_0">一开始的解决方案</h2>

<p>由于延迟的时间不确定， 因此开发同学将这一块的逻辑进行了改进，那就是如果没有查到依赖的数据，那么线程进入睡眠，然后重试几次，如果仍然失败，那没办法， 记录错误日志，后面再手工进行处理。<br/>
然而事实表明，修复之后情况并没有缓解，而且本地模拟问题的时候依然会出现数据取不到的情况</p>

<h2 id="toc_1">排查问题</h2>

<p>这让人百思不得其解，我们只好认为是代码的问题，因为我们监控了mybatis的查询执行情况，并且禁用了缓存，发现即时的查询并没有返回结果，这就变得很诡异了，这是什么情况？<br/>
也是出于偶然吧， 发现了方法上面的<code>@Transcational</code>注解，这个注解的默认事物隔离级别是<code>repeatable_read</code>，也就是<code>可重复读</code>, 简单说就是在同一个事物中，同一个查询不管在什么位置执行，得到的结果都是一样的， 不管其他会话有没有改变当前的数据。</p>

<h2 id="toc_2">解决问题</h2>

<p>尝试更改隔离级别，但似乎无效，可能spring或者驱动支持有限.<br/>
后来暂时干掉了事务注解，解决了问题</p>

<h2 id="toc_3">附</h2>

<p><img src="media/15528326468637/15528361407452.jpg" alt="" style="width:1050px;"/></p>

<p><img src="media/15528326468637/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6.png" alt="事务隔离 - 维基百科，自由的百科全书"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次线上疑似内存泄漏问题]]></title>
    <link href="fengbo.cool/190213-production-crash.html"/>
    <updated>2019-03-15T00:05:35+08:00</updated>
    <id>fengbo.cool/190213-production-crash.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">现象</h2>

<p>线上环境机器中有两个应用，最近发现机器的可用内存每天都在成阶梯式下降，因此怀疑是内存泄漏导致的问题</p>

<ul>
<li>现象1 ： linux系统日志
<img src="media/15525795356441/15528318231565.jpg" alt=""/></li>
<li>现象2 ： 机器状况
<img src="media/15525795356441/15528318499218.jpg" alt=""/>
23点系统宕机
<img src="media/15525795356441/15528319024343.jpg" alt=""/>
cpu压力正常
<img src="media/15525795356441/15528319063789.jpg" alt=""/>
io正常</li>
<li>现象3 : OOM日志<br/>
没有OOM日志, tomcat配置正常</li>
<li>现象4 : 应用负载<br/>
查看日志发现负载不高， 但是23点的时候执行了一个python脚本， 内存占用&gt;100M</li>
</ul>

<h2 id="toc_1">原因推测</h2>

<p>因为没有系统当时的内存快照和OOM日志;因此无法准确判断宕机原因.<br/>
推测是早上应用中触发了某个操作，导致内存泄漏，10:20分左右内存降到了最低点, 最后晚上23:00的脚本由于申请了大量内存，导致了系统内存不足而被kill掉。<br/>
两个系统均有可能发生内存泄漏</p>

<h2 id="toc_2">问题跟踪&amp;解决</h2>

<p>临时增加了机器内存。<br/>
另外定时打印应用的内存快照，观察是否存在内存泄漏.</p>

<pre><code class="language-text">jmap -histo:live $java_pid | head -100 &gt;&gt; ~/jmap.log
jstack -lF $java_pid&gt;&gt; ~/jstack.log
</code></pre>

<p>长期来看，一是不能因为系统宕机而长时间使系统处于无妨访问的状态，可以使用运维工具监控并且自动重启，自己脚本实现也可以。 二是需要规范大家的编码习惯， 减少低级失误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐系统算法]]></title>
    <link href="fengbo.cool/recommend-system-alg.html"/>
    <updated>2019-03-09T20:44:20+08:00</updated>
    <id>fengbo.cool/recommend-system-alg.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15521354602578/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95-2.png" alt="推荐系统算法-2"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大数据知识体系梳理]]></title>
    <link href="fengbo.cool/big-data-summary.html"/>
    <updated>2019-01-19T21:30:52+08:00</updated>
    <id>fengbo.cool/big-data-summary.html</id>
    <content type="html"><![CDATA[
<p>2019年，花一年的时间去慢慢的写一下体系中的一些东西，同时进行系统的学习；<br/>
<img src="media/15479046524543/BI%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86.png" alt="BI体系梳理"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次java版本问题的排查过程]]></title>
    <link href="fengbo.cool/190118-production-crash.html"/>
    <updated>2019-01-19T00:29:22+08:00</updated>
    <id>fengbo.cool/190118-production-crash.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">问题描述</h2>

<p>我们会提供一些jar包出去给业务同学，然后发现报错:<br/>
<code>com.**.**, unsupported major.minor version 52.0</code><br/>
52表示的是java8<br/>
这明显是我们提供的jar包的版本太高了，好吧，还好我们的客户端刚切换java8没多久，没有用到java8的特性，所以改一下目标版本到1.7重新打一个吧，打完之后发现还是不行，这就尴尬了</p>

<h2 id="toc_1">排查&amp;解决</h2>

<p>查来查去很蛋疼，尽管降低了版本，业务方还是报一样的问题，然后业务方如果升级到java8的话是OK的， 说明还是我们提供的包有问题；<br/>
既然还是报这个问题的话，只能到环境里面看一下服务器里面的代码的版本了，跑到对应的资源目录下面查看原始代码:</p>

<ol>
<li><code>jav -xvf **.jar</code> 解压缩</li>
<li>找到对应的类， <code>javap -verbose ***.class</code>, 反编译看一下代码的版本，发现<code>major:52</code><br/>
这就奇怪了，我明明改了版本了再打包的:
<img src="media/15478289621564/15478295213415.jpg" alt="" style="width:399px;"/>
在本地进行模拟，先打成1.8的包，然后再打1.7的包，发现1.7出来的包，竟然还是52的：
<img src="media/15478289621564/15478297070941.jpg" alt="" style="width:788px;"/>
难道是缓存? 先进行<code>mvn clean</code>之后再打包，发现正常了<br/>
:(<br/>
使用idea的菜单进行的操作，以后还是命令行吧..</li>
</ol>

]]></content>
  </entry>
  
</feed>
